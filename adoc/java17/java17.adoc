= Java 17, le record & pattern matching c‚Äôest pour maintenant ?
Antoine Salesse - a.salesse@younup.fr
:toc: preamble
:caution-caption: ‚ö†
:tabsize: 2
:source-highlighter: rouge
:docinfo: private

Promis jur√©, cet article n‚Äôest pas une liste des "nouvelles fonctionnalit√©s de Java" (https://docs.oracle.com/javase/specs/jls/se17/html/index.html[JLS]footnote:[JLS : Java Language Specification] /
https://stackoverflow.com/a/51286665[JSR]footnote:[JSR : Java Specification Request] / https://stackoverflow.com/a/51286665[JEP]footnote:[JEP : JDK Enhancement Proposal]).

Depuis sa sortie en septembre 2021, les articles sur Java *17* pleuvent.

Ok, √ßa y est, on a bien compris que cette version est une https://stackoverflow.com/a/51286665[LTS]footnote:[LTS : Long Term Support].

Mais c‚Äôest aussi bien plus que cela. +
C‚Äôest une milestone de l‚Äôobjectif ambitieux nomm√© +
*"Record and Array Pattern Matching"*.

Cet objectif est un ensemble de fonctionnalit√©s synergiques :

* Les `instanceof` avec "Type Patterns" (dispo en 16)
* Les Switch on Patterns (Java 17 preview, et probablement dispo en 19)
* La d√©construction de `record` (Peut-√™tre Java 19 preview)
* La d√©construction d‚Äôarray (Java 19+ ?)
* Les imbrications de patterns (pas de visibilit√© de dispo)

C‚Äôest donc de ces features dont on parle ici :

* √Ä quoi elles servent ?
* Comment et dans quels contextes les utiliser ?
* Qu‚Äôapportent-elles √† notre code ?

Et avec bien s√ªr des exemples de code !

== R√©volutionner Java, oui, mais pourquoi ?

Quand on souhaite am√©liorer un produit, on commence par se demander o√π les efforts seraient les plus b√©n√©fiques. +
Si on veut am√©liorer Java, on doit alors se demander "Que fait-on le plus souvent en Java, qui m√©riterait un upgrade ?"

Aujourd‚Äôhui le design de nos backend d‚Äôapplications de gestions pousse (üå±) autour d‚Äôune probl√©matique : +
*Faire varier des comportements en fonction de cas d‚Äôusage*

Dans ce genre d‚Äôapplications, quelle que soit l‚Äôarchitecture choisie ou le style dev, on se retrouve √† un moment ou un autre √† :

1.{nbsp}Mod√©liser notre domaine m√©tier ::
Cela peut √™tre fait dans un package sp√©cifique avec des https://en.wikipedia.org/wiki/Plain_old_Java_object[POJO], ou avec des `Entity` https://en.wikipedia.org/wiki/Jakarta_Persistence[JPA]. +
La seconde option est la plus r√©pandue, mais ce n‚Äôest pas ma pr√©f√©r√©e.
Je trouve que c‚Äôest une erreur de concevoir le business d‚Äôune application autour d‚Äôune base de donn√©es. +
2.{nbsp}√âcrire des https://en.wikipedia.org/wiki/Data_transfer_object[DTO] ::
Dans l‚Äôid√©al, un DTO est immutable (Il n‚Äôy a aucune raison de changer la repr√©sentation d‚Äôune donn√©e transmise √† un moment T). +
Le `record` est la structure de donn√©es la plus appropri√©e. +
Sinon, avant Java 14, on a les `@Value` de Lombok. +
On peut aussi se contenter de POJO mutables.

Dans nos applications modulaires, on peut avoir envie de partager ces structures de donn√©es entre des modules :

[plantuml,Mod√®le du domain Invoice,png]
----
@startuml
allow_mixing

node "Domain model" {
	class Invoice
}

node "Module letter" {
	usecase usecasePartialLettering
	usecasePartialLettering - Invoice
}

node "Module recovery" {
	usecase usecaseFirstReminder
	usecaseFirstReminder - Invoice
}

@enduml
----

Et bien pour faire varier les comportements des actions affectant ces classes, la https://en.wikipedia.org/wiki/Object-oriented_programming[Programation-Orient√©e-Objets] nous incite √† ajouter des m√©thodes sur nos classes de domaine. +
//En effet, c‚Äôest un Objet, il a un √©tat, et il peut porter des m√©thodes consommant ou modifiant cet √©tat.

Par exemple, pour la domain-class `Invoice`, le module `Letter` pourrait vouloir ajouter une m√©thode `calculateRemainingAmountToPay()`. +
Le module `Send` pourrait vouloir une m√©thode `getRecipients()`.

[plantuml,Mod√®le de domaine avec Invoice et cas d‚Äôutilisation,png]
----
@startuml
allow_mixing

node "Domain model" {


	class Invoice implements CalculableAmount, Sendable {
	Integer calculateRemainingAmountToPay()
	List<Person> getRecipients()
  }

  interface CalculableAmount
  interface Sendable
}

node "Module letter" {
  usecase usecaseLetterPartiel
  usecaseLetterPartiel - Invoice
}

node "Module send" {
  usecase usecaseFirstReminder
  usecaseFirstReminder - Invoice
}

@enduml
----

[source,java]
----
class Invoice implements CalculableAmount, Sendable {
	private String label;
	private CodeInvoice code;
	private Client client;
	private Receipt receipt;
	private Devise amount;

	@Override
	public Integer calculateRemainingAmountToPay(){
		...
	}

	@Override
	public List<Person> getRecipients(){
		...
	}

	...
}
----

Au bout d‚Äôun moment, notre domain-class `Invoice` a beaucoup de m√©thodes issues de diff√©rents modules. +
Le module `Letter` utilise `Invoice` et se retrouve √† pouvoir appeler les m√©thodes du module `Send`‚ÄØ; ce qui viole au moins :

* Le https://fr.wikipedia.org/wiki/Principe_de_s%C3%A9gr%C3%A9gation_des_interfaces[principe de s√©gr√©gation des interfaces]
* Le https://fr.wikipedia.org/wiki/Principe_de_responsabilit%C3%A9_unique[principe de responsabilit√© unique] (Car la classe Document a maintenant 2 raisons de changer : le contexte `Letter` et le contexte `Send`)

Effet bonus : Quand on change `Invoice` dans le cadre du contexte `Letter`, on doit recompiler/relivrer aussi le contexte `Send`.

=== Solution : s√©parer la logique m√©tier des structures sur lesquelles elle agit

Pour y parvenir, on utilisait jusque-l√† au moins ces 3 patterns :

* Le https://en.wikipedia.org/wiki/Visitor_pattern#Sources_3[visitor pattern]footnote:["Today, to express ad-hoc polymorphic calculations like this we would use the cumbersome visitor pattern". source : https://openjdk.java.net/jeps/405]
* Le https://en.wikipedia.org/wiki/Delegation_pattern[delegate pattern]
* Le pattern service-everywhere avec des m√©thodes √† 8 arguments (un anti-pattern d‚Äôapr√®s moi), qui nait de la programmation proc√©durale dans un monde d‚Äôhttps://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans[inversion de contr√¥le.]

Mais √† pr√©sent avec Java 17, une quatri√®me solution √©l√©gante s‚Äôoffre √† nous : Le Pattern Matching.

== Mais qu‚Äôest-ce que le pattern matching ?

Je pense qu‚Äôon ne peut pas couper √† la d√©finition de Wikip√©dia :

[quote,https://en.wikipedia.org/wiki/Pattern_matching]
--
In computer science, pattern matching is the act of checking a given sequence of tokens for the presence of the constituents of some pattern.
--

On a tendance √† penser alors aux expressions r√©guli√®res, mais non, il ne s‚Äôagit pas de cela.

L√†, les patterns √† matcher sont des structures de donn√©es :

* Des classes
* Des interfaces
* Des array
* Et bien s√ªr des records !

Je trouve que le cas du matching sur `instanceof` avec Type-Pattern est le plus facile √† comprendre. +
Avant Java 17, on avait √ßa :

[source,java]
----
if (invoice instanceof PaidInvoice) {
	letterService.letter(((PaidInvoice) invoice));
	return;
}
if (invoice instanceof DueInvoice) {
	recoveryService.remind(((DueInvoice) invoice));
}
----

Et √† pr√©sent :

[source,java]
----
if (invoice instanceof PaidInvoice paidInvoice) {
	letterService.letter(paidInvoice);
	return;
}
if (invoice instanceof DueInvoice dueInvoice) {
	recoveryService.remind(dueInvoice);
}
----

Ici le pattern √† matcher est l‚Äôappartenance aux classes `PaidInvoice` et `DueInvoice`.
On teste si l‚Äôinstance a un des types, et un cast implicite est fait vers une "binding variable" (`paidInvoice` ou `dueInvoice`).

== Comment le Pattern Matching remplace-t-il le visitor pattern ?

J‚Äôai promis des exemples de code, les voici.

Voici l‚Äôimpl√©mentation du visitor pattern avec le mod√®le de `Invoice` :

[source,java]
----

interface InvoiceVisitable {
	default void accept(InvoiceVisitor invoiceVisitor) {
		invoiceVisitor.visit(this);
	}
}

abstract class Invoice implements InvoiceVisitable {
}

class PaidInvoice extends Invoice {
}

class DueInvoice extends Invoice {
	private Integer reminderNumber = 0;

	public void incrementReminderNumber(){
		reminderNumber++;
	}

	public boolean hasAlreadyBeenReminded() {
		return reminderNumber >= 1;
	}
}

interface InvoiceVisitor {
	void visit(PaidInvoice paidInvoice);

	void visit(DueInvoice dueInvoice);
}

interface LetterService {
	void letter(PaidInvoice paidInvoice);
}

interface RecoveryService {
	void remind(DueInvoice dueInvoice);
}

record MainInvoiceVisitor(LetterService letterService, RecoveryService recoveryService) implements InvoiceVisitor {

	@Override
	public void visit(PaidInvoice paidInvoice) {
		letterService.letter(paidInvoice);
	}

	@Override
	public void visit(DueInvoice dueInvoice) {
		recoveryService.remind(dueInvoice);
	}
}

record InvoiceService(MainInvoiceVisitor mainInvoiceVisitor) implements InvoiceProcessing {

	public void handleInvoice(Invoice invoice) {
		invoice.accept(mainInvoiceVisitor);
	}
}

----

On observe que le rapport code utile / https://en.wikipedia.org/wiki/Boilerplate_code[boilerplate] n‚Äôest pas excellent.

Et maintenant :

[source,java]
----
record InvoiceService(LetterService letterService, RecoveryService recoveryService) implements InvoiceProcessing {

	public void handleInvoice(Invoice invoice) {
		if (invoice instanceof PaidInvoice paidInvoice) {
			letterService.letter(paidInvoice);
			return;
		}
		if (invoice instanceof DueInvoice dueInvoice) {
			recoveryService.remind(dueInvoice);
		}
	}
}
----

Le `InvoiceService` se suffit √† lui-m√™me, et la lisibilit√© me semble tr√®s acceptable.

Mais avez-vous remarqu√© quelque chose dans ce dernier bout de code ?

Le cas o√π `invoice` est d‚Äôun autre type n‚Äôest pas g√©r√© ! +
Et non, pas de `throw new NotImplementedException()` cette fois-ci. +

C‚Äôest l√† que la fonctionnalit√© Java 15 de types scell√©s intervient. +
Modifions un peu notre mod√®le :

[source,java]
----
abstract sealed class Invoice permits PaidInvoice, DueInvoice {
}

final class PaidInvoice extends Invoice {
}

final class DueInvoice extends Invoice {
	private Integer reminderNumber = 0;

	public void incrementerNombreReminder(){
		reminderNumber++;
	}

	public boolean hasAlreadyBeenReminded() {
		return reminderNumber >= 1;
	}
}
----

Traduction en fran√ßais : ::
Il n‚Äôexiste que 2 types de `Invoice` possibles : `PaidInvoice` et `DueInvoice`. +
Ces derni√®res ne peuvent √™tre √©tendues. +
Point.

Cela donne donc :

[source,java]
----
record InvoiceService(LetterService letterService, RecoveryService recoveryService) implements InvoiceProcessing {

	public void handleInvoice(Invoice invoice) {
		switch (invoice) {
			case PaidInvoice paidInvoice -> letterService.letter(paidInvoice);
			// case DueInvoice dueInvoice -> recoveryService.remind(dueInvoice);
		}
	}
}
----

J‚Äôai comment√© le cas de la `DueInvoice` afin d‚Äôobserver ce que nous disent le compilateur et l‚ÄôIDE :

image::java_the_switch_statement_does_not_cover_all_possible_input_values.png[alt="java: the switch statement does not cover all possible input values IntelliJ"]

image::java_compile_error_java_17_the_switch_statement_does_not_cover_all_possible_input_values.png[alt="java compile error java 17 the switch statement does not cover all possible input values"]

On doit alors d√©clarer le `Consumer<? extends Invoice>` de tous les cas restants, ou bien les grouper dans un `default` :

[source%linenums,java,highlight=6..7]
----
record InvoiceService(LetterService letterService, RecoveryService recoveryService) implements InvoiceProcessing {

	public void handleInvoice(Invoice invoice) {
		switch (invoice) {
			case PaidInvoice paidInvoice -> letterService.letter(paidInvoice);
			// case DueInvoice dueInvoice -> recoveryService.remind(dueInvoice);
			default -> LOGGER.info("Cool y a rien √† faire pour le cas l√† !");
		}
	}
}
----

Avec cette syntaxe, le langage nous apporte une validation m√©tier de plus √† la compile time (soit plus t√¥t qu‚Äô√† la runtime. Tout ce qui r√©duit la boucle de feedback est b√©n√©fique). +
C‚Äôest les TDDistes qui sont contents.

Et si on allait encore plus loin ? +
Allez, ajoutons une feature preview de Java 17 : un "Guarded Pattern"

[source%linenums,java,highlight=9..9]
----
record InvoiceService(
		LetterService letterService,
		RecoveryService recoveryService)
		implements InvoiceProcessing {

	public void handleInvoice(Invoice invoice) {
		switch (invoice) {
			case PaidInvoice paidInvoice -> letterService.letter(paidInvoice);
			case DueInvoice dueInvoice && dueInvoice.hasAlreadyBeenReminded() -> recoveryService.startRecovery(dueInvoice);
			case DueInvoice dueInvoice -> recoveryService.remind(dueInvoice);
		}
	}
}
----

Un "Guarded Pattern" permet d‚Äôajouter √† notre pattern des conditions sur les valeurs de l‚Äôobjet match√© en plus de son type.

Alors c‚Äôest tr√®s bien tout √ßa, mais l‚Äôobjectif √† terme du pattern matching va encore plus loin en ce qui concerne les records. +

Reprenons notre exemple de `Invoice`, mais consid√©rons qu‚Äôelle vient d‚Äôarriver d‚Äôun `Controlleur` sour forme de DTO (et donc de record) :

[source,java]
----
record Invoice(String code, String label, Integer amount, ZonedDateTime creationDate, ...){}
----

Je ne lui donne que quelques champs, mais consid√©rons en plus qu‚Äôil y a en une vingtaine, une centaine, beaucoup...

Quand je veux mapper cette invoice vers un usecase, alors ce dernier n‚Äôa tr√®s certainement besoin que de seulement quelques-uns de ces champs.
Le code suivant serait donc une erreur de design :

[source%linenums,java,highlight=8..8]
----
@RestController
class InvoiceControlleur {

	@PostMapping
	@ResponseStatus(HttpStatus.CREATED)
	public Long create(@RequestBody Invoice invoice) {
		Preconditions.checkNotNull(invoice);
		notifyNewInvoiceUseCase.handle(invoice);
		return invoiceService.handle(invoice)
	}
}
----

Apr√®s Java 18 (En preview de Java 19 avec un peu de chance üçÄ), on va pouvoir d√©construire des structures de donn√©es.

// todo : introduire un exemple qui justifie de d√©crire la d√©construction

== Qu‚Äôest-ce que la "d√©construction"

Ce concept a un objectif similaire au I de SOLID : la s√©gr√©gation.

Si je re√ßois un objet avec 43 champs alors que j‚Äôen ai besoin que de 2, la "_deconstruction on pattern_" va m‚Äôaider.

Regardons √ßa avec du code.

J‚Äôai mon √©norme dto Invoice :

[source,java]
----
record Invoice(
	String code,
	String libell√©,
	Integer amount,
	ZonedDateTime dateCr√©ation,
	... // imaginez ici 39 autres champs
){}
----

Mais la r√®gle m√©tier que je veux appliquer ne porte que sur le `code` et le `amount`.
Je peux alors √©tendre le concept de `instanceof` pr√©c√©dent, en lui ajoutant une d√©construction du Record "Invoice" :

[source,java]
----
if (object instanceof Invoice(String code, Integer amount)) {
	myUseCase.handle(code, amount);
}
----

Ici, `type` et `price` sont des "binding variables" g√©n√©r√©es implicitement si l‚Äô`object` match le pattern `Product`.

=== Et √ßa sert √† quoi ?

1. D√©couplage
2. Expressivit√©

Je ne compte pas expliquer ici en quoi ces 2 principes logiciels sont b√©n√©fiques.

Comparez plut√¥t avec la m√©thode habituelle :

[source,java]
----
if (object instanceof Invoice) {
    Invoice invoice = ((Invoice) object);
    String type = invoice.getType();
    String price = invoice.getPrice();
    myUseCase.handle(type, price);
}
----

== La d√©construction d‚Äôarray

De la m√™me mani√®re que pour les `record`, on va bient√¥t pouvoir d√©construire des array afin de :

* Matcher sur sa structure (exemple : `myArray.size() == 3`)
* Binder ses √©l√©ments vers des variables

Voyez plut√¥t :

[source,java]
----
if (document instanceof Invoice[] { PayedInvoice payedInvoice, DueInvoice dueInvoice}) {
	receiptService.handle(payedInvoice);
	recoveryService.handle(dueInvoice);
} else if (document instanceof Contract[] { Contract contract }) {
    signatureService.handle(contract);
}
----

== Les autres fonctionnalit√©s √† venir

* L‚Äôimbrication de pattern
* D√©construction par m√©thode

== Qu‚Äôapporte √† notre code ces nouvelles fonctionnalit√©s ?

* Plus de validation √† la compile-time, et donc une boucle de feedback plus rapide.
* D√©velopper plus intuitivement (le compilateur nous dis ce qu‚Äôon a oubli√©)
* Faire √©merger de meilleurs designs

=== Dans quels langages on en trouve d√©j√†

* https://docs.scala-lang.org/tour/pattern-matching.html[Scala]
* https://doc.rust-lang.org/rust-by-example/flow_control/match.html[Rust]

== Et Java 18/19 alors ?

√Ä l‚Äô√©criture de ces lignes, Java 18 est en phase de release candidate. +
Cela signifie que la listes de ces features est fix√©e. +
En ce qui concerne le pattern matching, on y retrouve la JEP 420 : Pattern Matching for switch (Second Preview) +
Cette seconde preview apporte des corrections de syntaxe et de compilation mineures, qui n‚Äôaffecte pas les explications pr√©c√©dentes.
Java 19 est en early-access avec une seule JEP. +
J‚Äôesp√®re y trouver la d√©construction de record/array/m√©thode en preview.

== Conclusion

J‚Äôai pass√© en revue les fonctionnalit√©s phares du "record and array pattern matching", en appuyant sur "dans quels contextes les utiliser ?", "pourquoi les utiliser ?". +
Les principales sont d√©j√† dans Java 17, d‚Äôautres sont dans sa preview, et les restantes ne tarderont pas. +
Cette r√©volution du langage est probablement au niveau de la r√©volution des Stream et de l‚ÄôAPI Function de Java 8.