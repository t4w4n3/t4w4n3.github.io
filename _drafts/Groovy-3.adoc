= Groovy (3), le langage JVM orient√© productivit√©
Antoine Salesse - t4w4n3 - <a.salesse@younup.fr>
:toc: preamble
:toclevels: 3

Java est un langage pr√©-compil√©.

[plantuml,javagroovy,png]
----
@startuml
(Java) -> (Use case 2)
@enduml
----
image::image-2022-03-18-14-11-19-701.png[]

Dans le monde de la Java Virtual Machine,

Dans les projets logiciels it√©ratifs, incr√©mentaux et adaptatifs, et dans un monde o√π on veut r√©agir rapidement au changement, on veut coder VITE, ne pas r√©inventer la roue (et encore moins la roue carr√©e).

Une lib existe pour faire ce qu‚Äôon a besoin ?
Elle est stable, maintenue, ses edge case sont test√©s ?
Ok on l‚Äôembarque plut√¥t que de recoder la feature.

Dans le monde Java, on a bien des frameworks et des lib √† foison remplies d‚Äôutils, de helpers, et d‚Äôannotations :

* Springboot
* Lombok
* Micronaut
* Apache commons
* Guava

Et j‚Äôen passe.

Mais on a aussi des langages !

* Kotlin
* Scala Et ...
* *Groovy*

Apr√®s l‚Äôavoir utilis√© dans mes stack de test, je l‚Äôai utilis√© pendant presque 2 ans en production; je n‚Äôavais jamais utilis√© un transcodage pens√©es->code aussi efficace.

Cet article pr√©sente les features de Groovy (3.0.9) pour coder ses id√©es √† toute vitesse.

== Les facettes de Groovy

Voil√† les caract√©ristiques et principes qui d‚Äôapr√®s moi, permettent √† Groovy d'√™tre si efficace :

=== Une courbe d‚Äôapprentissage plate

La transition Java -> Groovy se fait tr√®s facilement compar√© √† Kotlin et Scala.

Pourquoi ?

Une ligne java compile aussi en Groovy !

Et oui, on peut donc apprendre Groovy *it√©rativement* depuis du Java.

=== Convention-over-configuration

Les conventions plut√¥t que la configuration.

Admettons-le, configurer c‚Äôest lourd.
C‚Äôest surtout dans le design et l'√©criture du code m√©tier qu‚Äôon souhaite d√©penser notre pr√©cieux temps.

C‚Äôest probablement pour cette raison que les frameworks Springboot et Micronaut sont si appr√©ci√©s‚ÄØ; ils appliquent ce concept.

Ma s√©lection des features Groovy qui soutiennent ce principe :

==== List et map Literals

Si je devais citer UNE seule feature de Groovy, ce serait celle-ci.
D√©clarer et initialiser des collections et des map en java est tr√®s tr√®s verbeux.

===== List literals

Comparez vous-m√™me pour une liste (mutable) :

Java :

[source,java,linenums]
----
var users = new ArrayList<>() {{
    add(user1);
    add(user2);
}};
----

Je suis sympa, c‚Äôest du Java 11, ce qui nous √©conomise le type.
Mais on peut aller se gratter pour la trailing-comma (virgule finale), c‚Äôest les reviewers qui sont contents ;)

Groovy :

[source,groovy,linenums]
----
var users = [user1, user2]

// Ou bien :
var user2 = [
    user1,
    user2,
]
----

Par *convention*, `users` est une `ArrayList`.
Mais on aurait pu avoir un autre type de `Collection` logiquement, voire un array :

[source,groovy,linenums]
----
User[] usersArray = [
	user1,
	user2,
].toArray()

LinkedList<User> usersLinkedList = [
    user1,
    user2,
] as LinkedList

Set<User> usersSet = [
    user1,
    user2,
].toSet()

var usersForever = [
    user1,
    user2,
].asImmutable()
----

===== Et idem pour les map

Java (√† grand renfort d‚Äôimport static) :

[source,java,linenums]
----
import static java.util.Map.entry;
import static java.util.Map.ofEntries;

var userByGroup = ofEntries(
    entry(groupe4, user1),
    entry(groupe2, user2)
);
----

L√† aussi, on est tr√®s content du type dynamique, √† partir de Java 11.

Mais en Groovy, c‚Äôest bouilli √† la plus pure charge utile :

[source,groovy,linenums]
----
var userByGroup = [
        (groupe4): user1,
        (groupe2): user2,
]
----

Aucun caract√®re n‚Äôest superflu.
M√™me les parenth√®ses de cl√©s sont bien de la charge utile, car elles indiquent que la cl√© est une instance d‚Äôobjet et non la `String` `"groupeX"`.

==== Default getters and setters

Les getters et setters sont facultatifs et ajout√©s implicitement sur tous les champs avec le scope par d√©faut (empty), comme avec les record et les data/value-class Lombok.

[source,groovy,linenums]
----
class Foo {
    int id
}
var foo = new Foo(id:1)
assert foo.getId() == 1
----

==== Les affectations sont des alias des setters

[source,groovy,linenums]
----
foo.id = 2
// Dans le bytecode c‚Äôest foo.setId(2) qui est appel√©
----

Regardez, si on surcharge le `setId` par d√©faut et qu‚Äôon y place un breakpoint, ce code y passe.

image::surcharge-setId.png[]

==== Les r√©cup√©rations sont des alias des getters

[source,groovy,linenums]
----
foo.id = 2
// Dans le bytecode c‚Äôest foo.getId() qui est appel√©
----

Il est aussi surchargeable.

==== Un constructeur par d√©faut avec des "named parameters"

[source,groovy,linenums]
----
class User {
    int id
    String name
}
var user = new User(id:1, name: 'foo')
----

==== Default method arguments

Les param√®tres de m√©thodes peuvent √™tre rendu facultatif :

[source,groovy,linenums]
----
String foobarizeSomeStuff(String stuff1, int stuff2 = 0) {
    println "$stuff1 + : $stuff2"
}
foobarizeSomeStuff('Fizz', 8) == 'Fizz : 8'
foobarizeSomeStuff('Fizz') == 'Fizz : 0'
----

On a √©conomis√© la m√©thode `foobarizeSomeStuff(String stuff1)`

==== Le scope par default est `public`

Plus besoin de sp√©cifier le scope public

image::public-facultatif.png[]

L‚Äôide nous l‚Äôindique d‚Äôailleurs en grisant les keyword facultatifs.

==== Default obvious imports

Plus besoin des imports √©vidents, ils sont faits implicitement :

** java.lang.*
** java.util.*
** java.io.*
** java.net.*
** groovy.lang.*
** groovy.util.*
** java.math.BigInteger
** java.math.BigDecimal

==== Plus besoin de l‚Äôextension `.class` :

[source,java,linenums]
----
Class<App> appClass = App.class;
----

[source,groovy,linenums]
----
Class<App> appClass = App
----

==== Manipuler des `File` devient simple !

R√©cup√©rer le contenu text d‚Äôun fichier ?
Trop facile.
√âcrire du text dans un fichier ?
Pareil.

[source,groovy,linenums]
----
var file = new File("asset/templates/one.tmpl")
var textContent = file.text
textContent += '''
final line
'''
file << textContent // Alias vers file.write(textContent)
----

Je vous ne le fais pas en java, car vous avez d√©j√† en t√™te le bazar d‚Äô`InputStream` et `OutputStream` habituel üòâ

==== Plus besoin de point virgule

Attendez, je le r√©p√®te.

*Plus besoin de point virgule*

C‚Äôest une √©tape d√©cisive pour l‚Äôobtention d‚Äôun code avec une charge utile maximale.

=== Des op√©rateurs de haut niveau d‚Äôabstraction

Groovy est inspir√© de Python et Ruby pour ses op√©rateurs, dont voici mes petits pr√©f√©r√©s :

==== 1. Le Spread operator `*.`

Il permet d‚Äôinvoquer une action sur tous les √©l√©ments d‚Äôune liste disposant de cette action.

[source,groovy,linenums]
----
class User {
	String name
}
var users = [new User(name: 'titi'), new User(name: 'toto')]
println users*.name
----

Ici, on r√©cup√®re et affiche tous les userNames.

En Java, √ßa aurait √©t√© l√©g√®rement plus verbeux :

[source,java,linenums]
----
System.out.println(users.stream().map(user -> user.getName()).collect(Collectors.toList()))
----

==== 2. L‚Äôequal operator `==`

Hein mais on a un equal-equal en java, que nous chantonne-tu ?

Oui mais celui de Groovy est en fait un alias de `.equals()` si et seulement si ce dernier existe dans la class (avec une m√©thode `hashcode()`).
Alors la comparaison de 2 instances identiques sera true en Groovy (false en java)

[source,groovy,linenums]
----
import groovy.transform.EqualsAndHashCode

@EqualsAndHashCode
class Foo {
	Integer a
}
var one = new Foo(a:1)
var two = new Foo(a:1)
assert one == two
----

Je trouve √ßa plus intuitif.

L'√©galit√© de java est transf√©r√© sur l‚Äôop√©rateur `===` (on ne voudrait pas perdre de fonctionnalit√©s quand m√™me).

==== 3. Elvis operator `?:`

Il permet d‚Äôaffecter une valeur par d√©faut si l'√©l√©ment de gauche est false (null, z√©ro, et vide sont false en Groovy).

On √©vite alors les ennuyants ternaires du genre `displayName = user.name ? user.name : 'Anonymous'`.
Les Optional deviennent alors beaucoup moins n√©cessaires pour la null safety.

[source,groovy,linenums]
----
displayName = user.name ?: 'Anonymous'
----

`user` peut √™tre null ?
No problem, on en vient donc aux safe operators

==== 4. Safe Operators `?.` et `?[]`

Le premier est le "safe navigation op" et le 2√®me est le "safe index op".
Ils permettent tous deux d'√©viter les https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/NullPointerException.html[NPE].

[source,groovy,linenums]
----
var displayName = user?.name ?: 'Anonymous'
var secondBook = user?.books?[1] ?: Book.prototype
----

Avec seuls 3 op√©rateurs, on traite tous les cas de nullit√© possibles, et le one-liner se comprend tr√®s bien.

==== 5. Elvis assignment operator

Vous avez besoin d'√©viter √† tous pris la nullit√© d‚Äôune variable ?
Initialisez-la seulement quand elle est effectivement null avec l‚Äôelvis assigement op :

[source,groovy,linenums]
----
var userDto = userRestRepository.get('123')
userDto.name ?= 'John Smith'
----

Avec tous les op de null-safety, le principe de convention-over-configuration prend tout son sens.

==== 6. Range operator

On peut cr√©er des range d‚Äôentiers ou de char et it√©rer dessus directement :

[source,groovy,linenums]
----
('a'..'g').each {println it} // prints a b c d e f g
(1..5).each {println it} // prints 1 2 3 4 5
----

On peut aussi se servir des range pour sublister une collection :

[source,groovy,linenums]
----
[1, 2, 3, 4, 5][3..-1] == [4, 5]
[1, 2, 3, 4, 5][0..3] == [1, 2, 3, 4]
----

==== 7. Spaceship operator

C‚Äôest un alias de `.compareTo()`

[source,groovy,linenums]
----
assert ('a' <=> 'd') == -1
assert ('a' <=> 'a') == 0
assert ('g' <=> 'a') == 1
----

==== 8. Membership operator




=== Des high order functions natives sur les structures de donn√©es

L‚Äôactivit√© probablement la plus r√©currente dans un backend, est de manipuler des structures de donn√©es.

Les api Function et Stream ont r√©volutionn√© cette pratique. Mais l‚Äôintelligibilit√© est encore limit√©e par la verbosit√© de Java.

Voyez plut√¥t :

[source,groovy,linenums]
----
var entiers = [1, 2, 3]

//collectEntries (convert list to map)
Map<Integer, User> userById = entiers.collectEntries { [(it): userRepository.findById(it)] }

//groupBy
entiers.groupBy {it > 2} == [false:[1, 2], true:[3]]

//split
entiers.split {it > 2} == [[3], [1, 2]]

//average
entiers.average() == 2

//min with closure
var userWithMinBalance = entiers.min {userRepository.findById(it)?.balance }

//intersection
entiers.intersect([3, 4, 5]) == [3]

//indexation
entiers.indexed == [0:1, 1:2, 2:3]

//combinations
[[1, 2], ['a', 'b']].combinations() == [[1, a], [2, a], [1, b], [2, b]]

//permutations
entiers.permutations() == [[1, 2, 3], [3, 2, 1], [2, 1, 3], [3, 1, 2], [1, 3, 2], [2, 3, 1]]

//collate (partitionner)
(1..10).collate(3) == [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]
----

Et je ne m‚Äôarr√™te pas, car je suis √† court, mais parce que vous avez saisi l‚Äôid√©e : toute op√©ration de transformation existe nativement dans Groovy, et lex mixer entre elles donne des possibilit√©s infinies tout en conservant une lisibilit√© accrue.

== Int√©grer Groovy dans un projet Java existant

Il faut configurer la "joint compilation", pour compiler le Java ET le Groovy.
L‚Äôid√©al est d‚Äôutiliser *gmavenplus*:

[source,xml,linenums]
----
<plugin>
    <groupId>org.codehaus.gmavenplus</groupId>
    <artifactId>gmavenplus-plugin</artifactId>
    <version>1.13.0</version>
    <executions>
        <execution>
            <goals>
                <goal>execute</goal>
                <goal>addSources</goal>
                <goal>addTestSources</goal>
                <goal>generateStubs</goal>
                <goal>compile</goal>
                <goal>generateTestStubs</goal>
                <goal>compileTests</goal>
                <goal>removeStubs</goal>
                <goal>removeTestStubs</goal>
            </goals>
        </execution>
    </executions>
    <dependencies>
        <dependency>
            <groupId>org.codehaus.groovy</groupId>
            <artifactId>groovy-all</artifactId>
            <version>3.0.9</version>
            <scope>runtime</scope>
            <type>pom</type>
        </dependency>
    </dependencies>
</plugin>
----

== D√©marrer un projet Groovy from scratch

Plusieurs solutions s‚Äôoffrent √† nous :

=== Grails (Groovy on Rails)

C‚Äôest un framework du m√™me cr√©ateur, et maintenu par le m√™me soci√©t√© (Object Computing)

[source,bash]
----
grails create-app myApp
cd myApp
grails run-app
----

=== Springboot

Le spring initializr permet de g√©n√©rer un projet groovy (2.5.6 max en octobre 2021).

image::spring-initializr-groovy.png[]

=== Micronaut

Idem avec le Micronaut sarter

image::micronaut-starter-groovy.png[]

=== Gradle

On peut aussi faire des applications Gradle pur depuis gradle :

[source,bash]
----
#Gradle 7.2
gradle init
----

image::gradle-init-groovy.png[]

Ce qui nous donne cette jolie app Gradle avec une entrypoint class `App` :

image::gradle-app-structure.png[]

== Notre prod n‚Äôest pas pr√™te pour Groovy, mais notre stack de test l‚Äôest, comment faire ?

Ajouter la joint compilation gmavenplus en scope test uniquement ;)

Mais tant qu'√† faire du Groovy dans les tests, pourquoi pas utiliser directement https://spockframework.org/[Spock-framework] et https://gebish.org/[Gebish-framework] ? üòâ